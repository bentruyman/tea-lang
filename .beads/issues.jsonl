{"id":"tea-1","title":"Add std.process module","description":"Introduce a `std.process` module that provides process-spawning and management primitives. Initial scope could include:\n- Running child processes with configurable stdin/stdout/stderr piping\n- Capturing process output and exit status\n- Sending signals or terminating running processes\n- Querying environment variables and current working directory\n- Cross-platform abstractions so scripts behave consistently on macOS, Linux, and Windows\nConsider ergonomic wrappers that match Tea’s async story and ensure resource cleanup is deterministic.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:38:44.685299-05:00","updated_at":"2025-10-24T13:50:39.15009-05:00","closed_at":"2025-10-24T00:41:19.053075-05:00"}
{"id":"tea-10","title":"Implement incremental sync and debounced recompiles in tea-lsp","description":"Teach the Tea language server to accept incremental `didChange` updates so editors aren't forced to resend entire buffers. Track change ranges, rebuild the in-memory document, and debounce recompilation so we avoid thrashing the compiler on every keystroke. Include a follow-up check that diagnostics still publish correctly after consecutive partial edits.","notes":"Enabled incremental textDocument/didChange handling in tea-lsp by applying range-based edits to cached buffers, clearing analysis, and debouncing recompiles before publishing diagnostics.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T01:11:57.492277-05:00","updated_at":"2025-10-24T13:50:39.148076-05:00","closed_at":"2025-10-24T01:33:25.118989-05:00"}
{"id":"tea-11","title":"Add hover, completion, and go-to-definition to tea-lsp","description":"Extend the LSP so it surfaces semantic information from `tea-compiler`. Wire up resolver/type data to power hover tooltips, identifier completion, and go-to-definition. Ensure we only respond when the compiler can resolve symbols to avoid misleading empty results, and add regression coverage with fixture files where possible.","notes":"Implemented hover, completion, and go-to-definition handlers in tea-lsp using compiler AST symbol collection. Language server now advertises capabilities and returns document symbols for editor features.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T01:12:01.239624-05:00","updated_at":"2025-10-24T13:50:39.147746-05:00","closed_at":"2025-10-24T01:22:49.991577-05:00"}
{"id":"tea-12","title":"Run tea-lsp diagnostics off-thread with cancellation support","description":"Move compilation work in the language server onto spawned tasks so the main request loop stays responsive. Add cancellation handling via LSP `textDocument/didChange` and `$/cancelRequest` so in-flight compiles can be dropped when superseded. Confirm diagnostics are only published from the latest completed compile.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T01:12:04.913782-05:00","updated_at":"2025-10-24T13:50:39.147353-05:00","closed_at":"2025-10-24T12:46:23.753456-05:00"}
{"id":"tea-13","title":"Provide workspace-aware diagnostics in tea-lsp","description":"Enhance the server to track open modules and their dependencies so edits in one file can surface diagnostics in others. Consider file watchers or import graph traversal to keep module state fresh, and emit workspace-wide diagnostics where supported by the LSP. Document any limitations around project layout or stdlib resolution.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T01:12:08.419224-05:00","updated_at":"2025-10-24T13:50:39.147072-05:00","closed_at":"2025-10-24T12:43:38.154024-05:00"}
{"id":"tea-14","title":"Expose tea-lsp configuration and settings sync","description":"Support `workspace/didChangeConfiguration` so users can tweak language server behavior (e.g., backend selection, stdlib search paths, diagnostics toggles). Reflect configuration in the server capabilities, plumb settings into compile options, and persist sensible defaults when the client lacks settings support.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T01:12:11.696276-05:00","updated_at":"2025-10-24T19:51:37.25301-05:00","closed_at":"2025-10-24T19:51:37.25301-05:00"}
{"id":"tea-15","title":"Document Tea LSP installation and editor setup","description":"Write docs explaining how to install and run the `tea-lsp` binary, hook it up to common editors (Neovim, VS Code), and troubleshoot typical issues. Surface the guide in `docs/` and link from the README so contributors can discover it easily.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T01:12:15.787957-05:00","updated_at":"2025-10-24T16:24:34.512646-05:00","closed_at":"2025-10-24T16:24:34.512646-05:00"}
{"id":"tea-16","title":"Improve tea-lsp logging and progress reporting","description":"Tighten language-server observability with structured logs and progress notifications. Emit scoped info when compiles start/finish, optionally surface `window/workDoneProgress` updates for long-running diagnostics, and ensure failures always include enough context for debugging.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T01:12:20.977404-05:00","updated_at":"2025-10-24T13:50:39.150704-05:00","closed_at":"2025-10-24T13:39:50.051258-05:00"}
{"id":"tea-17","title":"Support docstrings in tea-lsp hovers","description":"Teach the language server to surface inline documentation for functions, structs, and fields. Decide on a docstring format (e.g., leading comments or specially marked blocks), parse the docs during compilation, and include them in hover responses so editors show rich descriptions alongside signatures.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T02:41:11.218367-05:00","updated_at":"2025-10-24T13:50:39.1505-05:00","closed_at":"2025-10-24T13:37:00.986625-05:00"}
{"id":"tea-18","title":"Provide type-aware completions in tea-lsp","description":"Teach tea-lsp to use compiler type information when producing completion items. Expose in-scope bindings and expected argument types from the compiler/typechecker, and filter completion candidates so editors see only symbols compatible with the position (e.g., strings when a string argument is expected).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T02:46:27.893202-05:00","updated_at":"2025-10-24T13:50:39.146752-05:00","closed_at":"2025-10-24T12:29:35.394408-05:00"}
{"id":"tea-19","title":"Propagate parser/resolver errors as diagnostics","description":"Ensure tea-lsp receives structured diagnostics for parser and resolver failures instead of only an error message. Update the compiler so parse and name-resolution errors always push Diagnostics entries with accurate spans before returning Err, eliminating the \"no diagnostics emitted\" fallback.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T02:58:21.58701-05:00","updated_at":"2025-10-24T13:50:39.146329-05:00","closed_at":"2025-10-24T12:36:07.822589-05:00"}
{"id":"tea-2","title":"Add std.http module","description":"Introduce a `std.http` module to make HTTP client interactions ergonomic. Potential features include:\n- High-level request helpers for common verbs (GET, POST, PUT, DELETE)\n- Streamed and buffered response handling with access to headers, status codes, and body\n- Support for async requests, cancellation, and timeouts\n- Configurable TLS, redirects, and cookie handling\n- Minimal server utilities (mock server, request matcher) to support testing and local development.\nStrive for an API that composes cleanly with Tea’s async primitives and error handling patterns.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-23T22:38:48.408073-05:00","updated_at":"2025-10-24T13:50:39.149901-05:00"}
{"id":"tea-20","title":"Disallow newline-separated closing bracket in struct generics","description":"Tighten the parser so type parameter lists for structs/functions must close with `]` on the same line as the name, rejecting layouts like `struct Box[T` newline `]`. Ensure we emit a clear diagnostic pointing to the stray closing bracket.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T08:56:49.855138-05:00","updated_at":"2025-10-24T19:51:37.252205-05:00","closed_at":"2025-10-24T19:51:37.252205-05:00"}
{"id":"tea-21","title":"Add docstring support to Tea stdlib","description":"Add descriptive docstrings for Tea's standard library functions and surface them through the compiler/LSP so hover information is available even though the stdlib is not authored in Tea source files. Investigate how to represent, store, and expose doc comments for generated or built-in bindings.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T14:05:55.497469-05:00","updated_at":"2025-10-24T16:05:02.93588-05:00","closed_at":"2025-10-24T16:05:02.93588-05:00"}
{"id":"tea-22","title":"feat: introduce match pattern matching syntax","description":"Add a `match` expression that can branch on both value comparisons and type discriminants. Initial syntax should support matching against literals, identifiers, and wildcards, allowing multi-pattern unions per case (e.g. `case \"y\" | \"yes\"`). Ensure a default `_` arm is supported and evaluate the match expression to the value of the chosen arm.","acceptance_criteria":"- A `match` construct exists with `case` arms returning expressions.\n- Multiple literals can be joined with `|` to share a branch.\n- `_` wildcard matches when no other pattern does.\n- Type-based matches are possible (e.g., variants/structs once implemented) or a plan exists for first-class support.\n- New syntax is documented in `docs/` and covered by compiler tests and `.tea` examples.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-24T19:50:58.85247-05:00","updated_at":"2025-10-25T02:31:26.293141-05:00","closed_at":"2025-10-25T02:31:26.293141-05:00"}
{"id":"tea-23","title":"feat: add const keyword for immutables","description":"Introduce a `const` keyword to define immutable bindings at compile time. Declarations should fail if reassignment is attempted, mirroring Zig's immutable semantics. Update the type checker and runtime representation so constant bindings propagate constness through the pipeline.","acceptance_criteria":"- `const` declarations compile and are enforced as immutable bindings.\n- Reassigning or mutating a `const` binding produces a clear diagnostic.\n- Existing `let` semantics remain unchanged.\n- Document the new keyword in language docs and add `.tea` examples demonstrating correct and failing usage.\n- Compiler tests cover parsing, type checking, and emitted IR/bytecode for const bindings.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-24T19:51:02.230829-05:00","updated_at":"2025-10-24T21:00:56.144082-05:00","closed_at":"2025-10-24T21:00:56.144082-05:00"}
{"id":"tea-24","title":"feat: support string interpolation literals","description":"Add backtick-delimited string literals that allow `${expr}` interpolation inside the literal. Ensure interpolated expressions are evaluated at runtime and concatenated into a single string result. Update the lexer, parser, and runtime string builder to handle this new literal form.","acceptance_criteria":"- Backtick strings (`` `...` ``) parse successfully and permit `${expr}` segments.\n- Interpolated expressions evaluate in place and produce the same value as manual concatenation.\n- Escaping rules are defined for backticks and `${` sequences.\n- Language documentation and `.tea` examples demonstrate interpolated strings.\n- Compiler tests exercise lexing, parsing, and codegen for interpolation.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-24T19:51:05.523242-05:00","updated_at":"2025-10-24T20:32:06.188185-05:00","closed_at":"2025-10-24T20:32:06.188185-05:00"}
{"id":"tea-25","title":"Enums support","description":"Add support for declaring enums in the language, e.g.\n\nenum Color\n  Red\n  Green\n  Blue\nend","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T20:40:37.885385-05:00","updated_at":"2025-10-25T01:34:28.736013-05:00","closed_at":"2025-10-25T01:34:28.736013-05:00"}
{"id":"tea-26","title":"Public vs private functions","description":"Only export functions from modules prefixed with the `pub` keyword.\n\n```\npub def hello(location: String)\n  `Hello #{location`\nend\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T20:59:16.015309-05:00","updated_at":"2025-10-24T23:18:25.154239-05:00","closed_at":"2025-10-24T23:18:25.154239-05:00"}
{"id":"tea-27","title":"Optional values and null","description":"Support optional values that can hold `null` using the `?` suffix syntax.\n\n```\nvar str: String? = null\nstr = \"Hello\"\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T20:59:17.650161-05:00","updated_at":"2025-10-25T11:57:48.915878-05:00","closed_at":"2025-10-25T11:57:48.915878-05:00"}
{"id":"tea-28","title":"Enforce flow-sensitive optional unwrapping","description":"Force `expr!` to type-check only when prior control-flow guarantees the optional is non-nil. Track paths like `if x == nil { return }` so subsequent code can treat `x` as non-optional and emit diagnostics when the unwrap is unsafe.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T23:10:58.701121-05:00","updated_at":"2025-10-24T23:32:22.819618-05:00","closed_at":"2025-10-24T23:32:22.819618-05:00"}
{"id":"tea-29","title":"Implement optional coalesce operator","description":"Add a `??` operator that returns the left operand when it is non-nil, otherwise evaluates and returns the right operand. Ensure it type-checks across optional and non-optional operands, lowers in both VM and AOT backends, and update docs/examples accordingly.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T23:11:11.318796-05:00","updated_at":"2025-10-24T23:47:49.356276-05:00","closed_at":"2025-10-24T23:47:49.356276-05:00"}
{"id":"tea-3","title":"Add std.os module","description":"Add a `std.os` module that provides access to operating-system level facilities. Target capabilities might include:\n- File and directory inspection APIs (metadata, permissions, timestamps)\n- Portable path utilities and environment-specific separators\n- System information queries (platform, architecture, available memory)\n- Process-level helpers like current user/group, locale, and timezone\n- Low-level syscalls or FFI hooks surfaced through safe abstractions.\nFocus on cross-platform behavior first, documenting where functionality may vary by host OS.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-23T22:38:52.906211-05:00","updated_at":"2025-10-24T13:50:39.149706-05:00"}
{"id":"tea-30","title":"Support optional chaining","description":"Introduce optional-chaining syntax (`expr?.prop`, `expr?.call(...)`) that safely navigates optionals without manual nil checks. The chain should short-circuit to nil when any link is nil, type-check against optional receivers, and lower to the VM and LLVM backends. Update docs and add regression examples.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T23:11:24.948268-05:00","updated_at":"2025-10-25T01:09:18.544542-05:00","closed_at":"2025-10-25T01:09:18.544542-05:00"}
{"id":"tea-31","title":"Optional values and null","description":"Support optional values that can hold `null` using the `?` suffix syntax.\n\n```\nvar str: String? = null\nstr = \"Hello\"\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-25T12:13:19.60052-05:00","updated_at":"2025-10-25T12:13:40.933575-05:00","closed_at":"2025-10-25T12:13:40.933575-05:00"}
{"id":"tea-32","title":"Replace logical operators with symbols","description":"Update language to use \u0026\u0026 and || instead of the and/or keywords.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-25T15:00:38.060093-05:00","updated_at":"2025-10-25T15:09:19.332634-05:00","closed_at":"2025-10-25T15:09:19.332634-05:00"}
{"id":"tea-33","title":"Refactor enums to use braces","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-25T13:56:43.453626-05:00","updated_at":"2025-10-25T14:43:27.863094-05:00","closed_at":"2025-10-25T14:43:27.863096-05:00"}
{"id":"tea-34","title":"feat: allow match as statement","description":"Expand Tea's match syntax so it can be used as a statement in addition to an expression.\\n\\nGoals:\\n- Permit match blocks where cases omit  and execute statement blocks.\\n- Adjust parser/grammar to recognize statement-form cases and ensure fall-through rules stay explicit.\\n- Update examples and docs to illustrate both expression and statement usage.\\n- Add compiler/runtime tests covering statement-style match control flow.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T09:46:13.600008-05:00","updated_at":"2025-10-26T10:19:39.060823-05:00","closed_at":"2025-10-26T10:19:39.060823-05:00"}
{"id":"tea-35","title":"Add union types with type discrimination","description":"## Summary\n- add a `union` type declaration that aggregates multiple types\n- allow unions to include structs and other unions\n- introduce an `is` type test expression for flow control\n\n## Details\n- update the parser, type checker, and runtime to understand union definitions\n- extend pattern matching to support `case is Type` checks\n- ensure `if value is Type` works for any declared type\n- add language examples and documentation describing the new behavior\n- refresh tree-sitter grammar so tooling recognizes unions and type tests\n\n## Testing\n- add examples covering unions inside match expressions and conditionals\n- extend compiler tests to exercise union definitions and `is` expressions","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T10:43:47.746758-05:00","updated_at":"2025-10-26T10:43:47.749721-05:00","closed_at":"2025-10-26T10:39:36.744183-05:00"}
{"id":"tea-36","title":"Introduce Void return type for empty functions","description":"Currently functions that do not return an explicit value yield Nil, which is still a first-class value used by optionals. Create a new Void type and update the compiler/runtime so implicit-returning functions produce Void instead.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T13:06:35.579214-05:00","updated_at":"2025-10-26T13:49:01.154104-05:00","closed_at":"2025-10-26T13:49:01.154104-05:00"}
{"id":"tea-37","title":"tea-8: parser \u0026 AST for errors-as-values","description":"Extend lexer/parser/AST to recognize  declarations, , , and error union annotations. Ensure resolver registers error types/variants and add design sketch baseline.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T16:42:24.191091-05:00","updated_at":"2025-10-26T22:14:29.968133-05:00","closed_at":"2025-10-26T22:14:29.968133-05:00"}
{"id":"tea-38","title":"tea-8: type system for errors-as-values","description":"Teach the type checker about error variants, function error unions, throw/try/catch semantics, and result propagation so unions compose correctly.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T16:42:29.68505-05:00","updated_at":"2025-10-26T22:14:33.624422-05:00","closed_at":"2025-10-26T22:14:33.624422-05:00"}
{"id":"tea-39","title":"tea-8: runtime \u0026 codegen support for errors-as-values","description":"Update bytecode, VM, and LLVM backend to represent error payloads, propagate throws, and execute try/catch control flow correctly.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T16:42:34.034005-05:00","updated_at":"2025-10-26T22:14:37.005123-05:00","closed_at":"2025-10-26T22:14:37.005123-05:00"}
{"id":"tea-4","title":"Move std.print into std.debug module","description":"Refactor `std.print` into a dedicated `std.debug` module to tighten the standard library organization. Key steps may include:\n- Introducing a `std.debug.print` (or similar) function that re-exports current printing behavior\n- Updating existing imports/usages across examples, tests, and runtime to reference the new module\n- Keeping backwards compatibility where practical, perhaps via a deprecated shim\n- Documenting the new module layout in standard library docs and release notes\nEnsure the move aligns with the emerging module structure and keeps formatting utilities easy to discover.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:42:42.150908-05:00","updated_at":"2025-10-24T13:50:39.149496-05:00","closed_at":"2025-10-24T00:38:24.531056-05:00"}
{"id":"tea-40","title":"tea-8: tooling, tests, and docs for errors-as-values","description":"Refresh tree-sitter grammar, add examples/tests, and document the new error handling model once implementation lands.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T16:42:39.124421-05:00","updated_at":"2025-10-26T22:14:40.196834-05:00","closed_at":"2025-10-26T22:14:40.196834-05:00"}
{"id":"tea-41","title":"Add for-of loop for list iteration","description":"Introduce `for \u003citem\u003e of \u003clist\u003e` syntax to iterate over lists, binding a fresh loop variable per element and executing a block until `end`.\n\n## Example Syntax\n```tea\nvar names = [\"Alice\", \"Bob\", \"Charlie\"]\n\nfor person of names\n  debug.print(greet(person))\nend\n```\n\n## Semantics\n- Evaluate list expression once\n- Bind loop variable per element (block-scoped)\n- Execute block for each element\n- Runs zero times if list is empty\n\n## Implementation Areas\n\n### Parser\n- Add `for` statement form: `for identifier of expression block end`\n- Update grammar.ebnf to include for_statement\n\n### Typechecker\n- Require `expression: List[T]`\n- Infer loop variable type as `T`\n- Emit type error for non-list iterables\n\n### Resolver\n- Introduce loop binding scoped to loop body\n- Handle shadowing rules\n\n### Runtime/Codegen\n- Desugar to index-based iteration over list length\n- Generate bytecode for list iteration\n- Support in AOT backend\n\n### Formatter\n- Preserve `for … of` with two-space indentation\n- `end` terminator alignment\n\n### Diagnostics\n- Clear errors for non-list iterables\n- Clear errors for invalid loop targets\n\n### Documentation \u0026 Examples\n- Add `examples/language/control_flow/for.tea`\n- Update grammar specification\n- Update language reference docs\n\n## Out of Scope (v1)\n- `break`/`continue` statements\n- Multi-binding or destructuring (e.g., `for key, value`)\n- Non-list iterables (dicts, strings, ranges)\n- List comprehensions\n\n## Open Questions\n1. Should it support dict iteration as key/value pairs?\n2. Should it support string iteration as characters?\n3. Should it support ranges (via `range(start, end)`)?\n4. Should we add an `enumerate` form for index + value?\n5. Should loop variable be read-only (immutable)?\n6. Should we permit shadowing of outer variables?\n\n## Recommendations\n- **v1**: Lists only, read-only loop variable\n- **Future**: Dict key/value pairs, string chars, ranges, enumerate via separate issues","design":"## Syntax Design\n```ebnf\nfor_statement = \"for\" identifier \"of\" expression block \"end\" ;\n```\n\nAligns with existing control flow (`while`, `until`, `unless`) using `end` terminator.\n\n## Type System\n- Expression must be `List[T]` for some type `T`\n- Loop variable has type `T` (inferred from list element type)\n- Loop variable is block-scoped, immutable\n\n## Execution Model\nDesugar to:\n```\nvar __list = \u003cexpression\u003e\nvar __index = 0\nwhile __index \u003c list.length(__list)\n  var \u003cidentifier\u003e = __list[__index]\n  \u003cblock\u003e\n  __index = __index + 1\nend\n```\n\n## Error Cases\n- Non-list iterable: \"Cannot iterate over type X, expected List[T]\"\n- Invalid binding target: handled by parser","acceptance_criteria":"- Parses `for \u003cvar\u003e of \u003clist\u003e ... end` syntax correctly\n- Formats for-of loops with proper indentation\n- Typechecks: loop var type equals list element type\n- Rejects non-list iterables with clear error message\n- Executes correctly for non-empty lists\n- Executes correctly for empty lists (zero iterations)\n- New example file `examples/language/control_flow/for.tea` runs successfully\n- Tree-sitter grammar recognizes for-of syntax\n- Parser tests cover for-of statements\n- Runtime tests verify iteration behavior\n- Type checker tests verify List[T] constraint","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-27T20:56:47.725076-05:00","updated_at":"2025-10-27T21:12:17.504794-05:00","closed_at":"2025-10-27T21:12:17.504794-05:00"}
{"id":"tea-5","title":"Add GitHub Action for PR builds","description":"Introduce GitHub Actions CI coverage for pull requests to ensure build and test checks run automatically. An initial workflow could:\n- Trigger on `pull_request` (and optionally `push` to main branches)\n- Install required toolchains (Rust stable, LLVM dependencies)\n- Run `cargo fmt --check`, `cargo clippy` (if configured), and `cargo test --workspace`\n- Invoke `cargo run -p tea-cli -- test --fail-fast` and `scripts/e2e.sh` where feasible\n- Cache build artifacts to speed up subsequent runs and upload sanitized logs on failure.\nDocument the workflow expectations so contributors understand the gates before merging.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:59:19.912801-05:00","updated_at":"2025-10-24T13:50:39.149217-05:00","closed_at":"2025-10-24T00:38:27.777389-05:00"}
{"id":"tea-6","title":"Create Language Server Protocol implementation","description":"Build an LSP server for Tea to bring editor integration up to par. Initial feature set should prioritize:\n- Syntax-aware diagnostics surfaced as users type (compilation errors, lexical issues)\n- Go-to-definition, hover tooltips, and symbol lookup based on the compiler’s semantic model\n- Formatting hooks that leverage `tea-cli fmt`\n- Incremental analysis and caching so feedback stays responsive on larger projects\n- Extensible architecture for future features such as inline evaluation or refactorings.\nDocument setup instructions for popular editors (VS Code, Neovim, Helix) and provide demos or GIFs once functional.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:59:25.669345-05:00","updated_at":"2025-10-24T23:21:42.391829-05:00","closed_at":"2025-10-24T23:21:42.391829-05:00"}
{"id":"tea-7","title":"Emit compiler warnings for bad code practices","description":"Enhance the compiler to detect and report common code hygiene issues. Focus areas could include:\n- Unused imports, variables, and function arguments\n- Deprecated APIs or language constructs\n- Shadowed bindings that may hide outer scope values\n- Suspicious control flow, such as unreachable code or always-true conditions\n- Configurable warning levels and suppression annotations so advanced users can opt out selectively.\nUpdate tests and docs to establish the new linting expectations and provide guidance on resolving warnings.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-23T22:59:30.641195-05:00","updated_at":"2025-10-24T13:50:39.148827-05:00"}
{"id":"tea-8","title":"Adopt errors-as-values pattern","description":"Rework error handling so Tea programs can treat errors as first-class values. Key steps could include:\n- Introducing a lightweight result type (e.g., `Result\u003cT, E\u003e`) or equivalent pattern in the language\n- Refactoring the standard library to expose fallible operations via explicit error returns instead of panics or implicit exceptions\n- Updating core language constructs (pattern matching, async) to interoperate smoothly with the new error model\n- Providing ergonomics for error propagation, aggregation, and formatting\n- Documenting migration guidance and updating examples/tests to showcase idiomatic usage.\nEnsure runtime semantics stay predictable and compiler diagnostics guide users toward the new APIs.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:59:34.686238-05:00","updated_at":"2025-10-26T22:14:43.46611-05:00","closed_at":"2025-10-26T22:14:43.46611-05:00"}
{"id":"tea-9","title":"Stand up first-class Tea language server","description":"","notes":"Deliver a robust Tea language server that offers diagnostics, editing assists, and workspace awareness for editors like Neovim and VS Code. Track enhancements across parsing, type analysis, and tooling integration so the LSP becomes a reliable daily driver.","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-10-24T01:11:42.214913-05:00","updated_at":"2025-10-24T16:49:14.470904-05:00","closed_at":"2025-10-24T16:49:14.470904-05:00"}
