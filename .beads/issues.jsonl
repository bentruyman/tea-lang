{"id":"tea-1","title":"Add std.process module","description":"Introduce a `std.process` module that provides process-spawning and management primitives. Initial scope could include:\n- Running child processes with configurable stdin/stdout/stderr piping\n- Capturing process output and exit status\n- Sending signals or terminating running processes\n- Querying environment variables and current working directory\n- Cross-platform abstractions so scripts behave consistently on macOS, Linux, and Windows\nConsider ergonomic wrappers that match Tea’s async story and ensure resource cleanup is deterministic.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:38:44.685299-05:00","updated_at":"2025-10-24T13:50:39.15009-05:00","closed_at":"2025-10-24T00:41:19.053075-05:00"}
{"id":"tea-10","title":"Implement incremental sync and debounced recompiles in tea-lsp","description":"Teach the Tea language server to accept incremental `didChange` updates so editors aren't forced to resend entire buffers. Track change ranges, rebuild the in-memory document, and debounce recompilation so we avoid thrashing the compiler on every keystroke. Include a follow-up check that diagnostics still publish correctly after consecutive partial edits.","notes":"Enabled incremental textDocument/didChange handling in tea-lsp by applying range-based edits to cached buffers, clearing analysis, and debouncing recompiles before publishing diagnostics.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T01:11:57.492277-05:00","updated_at":"2025-10-24T13:50:39.148076-05:00","closed_at":"2025-10-24T01:33:25.118989-05:00"}
{"id":"tea-11","title":"Add hover, completion, and go-to-definition to tea-lsp","description":"Extend the LSP so it surfaces semantic information from `tea-compiler`. Wire up resolver/type data to power hover tooltips, identifier completion, and go-to-definition. Ensure we only respond when the compiler can resolve symbols to avoid misleading empty results, and add regression coverage with fixture files where possible.","notes":"Implemented hover, completion, and go-to-definition handlers in tea-lsp using compiler AST symbol collection. Language server now advertises capabilities and returns document symbols for editor features.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T01:12:01.239624-05:00","updated_at":"2025-10-24T13:50:39.147746-05:00","closed_at":"2025-10-24T01:22:49.991577-05:00"}
{"id":"tea-12","title":"Run tea-lsp diagnostics off-thread with cancellation support","description":"Move compilation work in the language server onto spawned tasks so the main request loop stays responsive. Add cancellation handling via LSP `textDocument/didChange` and `$/cancelRequest` so in-flight compiles can be dropped when superseded. Confirm diagnostics are only published from the latest completed compile.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T01:12:04.913782-05:00","updated_at":"2025-10-24T13:50:39.147353-05:00","closed_at":"2025-10-24T12:46:23.753456-05:00"}
{"id":"tea-13","title":"Provide workspace-aware diagnostics in tea-lsp","description":"Enhance the server to track open modules and their dependencies so edits in one file can surface diagnostics in others. Consider file watchers or import graph traversal to keep module state fresh, and emit workspace-wide diagnostics where supported by the LSP. Document any limitations around project layout or stdlib resolution.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T01:12:08.419224-05:00","updated_at":"2025-10-24T13:50:39.147072-05:00","closed_at":"2025-10-24T12:43:38.154024-05:00"}
{"id":"tea-14","title":"Expose tea-lsp configuration and settings sync","description":"Support `workspace/didChangeConfiguration` so users can tweak language server behavior (e.g., backend selection, stdlib search paths, diagnostics toggles). Reflect configuration in the server capabilities, plumb settings into compile options, and persist sensible defaults when the client lacks settings support.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T01:12:11.696276-05:00","updated_at":"2025-10-24T19:51:37.25301-05:00","closed_at":"2025-10-24T19:51:37.25301-05:00"}
{"id":"tea-15","title":"Document Tea LSP installation and editor setup","description":"Write docs explaining how to install and run the `tea-lsp` binary, hook it up to common editors (Neovim, VS Code), and troubleshoot typical issues. Surface the guide in `docs/` and link from the README so contributors can discover it easily.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T01:12:15.787957-05:00","updated_at":"2025-10-24T16:24:34.512646-05:00","closed_at":"2025-10-24T16:24:34.512646-05:00"}
{"id":"tea-16","title":"Improve tea-lsp logging and progress reporting","description":"Tighten language-server observability with structured logs and progress notifications. Emit scoped info when compiles start/finish, optionally surface `window/workDoneProgress` updates for long-running diagnostics, and ensure failures always include enough context for debugging.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T01:12:20.977404-05:00","updated_at":"2025-10-24T13:50:39.150704-05:00","closed_at":"2025-10-24T13:39:50.051258-05:00"}
{"id":"tea-17","title":"Support docstrings in tea-lsp hovers","description":"Teach the language server to surface inline documentation for functions, structs, and fields. Decide on a docstring format (e.g., leading comments or specially marked blocks), parse the docs during compilation, and include them in hover responses so editors show rich descriptions alongside signatures.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T02:41:11.218367-05:00","updated_at":"2025-10-24T13:50:39.1505-05:00","closed_at":"2025-10-24T13:37:00.986625-05:00"}
{"id":"tea-18","title":"Provide type-aware completions in tea-lsp","description":"Teach tea-lsp to use compiler type information when producing completion items. Expose in-scope bindings and expected argument types from the compiler/typechecker, and filter completion candidates so editors see only symbols compatible with the position (e.g., strings when a string argument is expected).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T02:46:27.893202-05:00","updated_at":"2025-10-24T13:50:39.146752-05:00","closed_at":"2025-10-24T12:29:35.394408-05:00"}
{"id":"tea-19","title":"Propagate parser/resolver errors as diagnostics","description":"Ensure tea-lsp receives structured diagnostics for parser and resolver failures instead of only an error message. Update the compiler so parse and name-resolution errors always push Diagnostics entries with accurate spans before returning Err, eliminating the \"no diagnostics emitted\" fallback.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T02:58:21.58701-05:00","updated_at":"2025-10-24T13:50:39.146329-05:00","closed_at":"2025-10-24T12:36:07.822589-05:00"}
{"id":"tea-2","title":"Add std.http module","description":"Introduce a `std.http` module to make HTTP client interactions ergonomic. Potential features include:\n- High-level request helpers for common verbs (GET, POST, PUT, DELETE)\n- Streamed and buffered response handling with access to headers, status codes, and body\n- Support for async requests, cancellation, and timeouts\n- Configurable TLS, redirects, and cookie handling\n- Minimal server utilities (mock server, request matcher) to support testing and local development.\nStrive for an API that composes cleanly with Tea’s async primitives and error handling patterns.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-23T22:38:48.408073-05:00","updated_at":"2025-10-24T13:50:39.149901-05:00"}
{"id":"tea-20","title":"Disallow newline-separated closing bracket in struct generics","description":"Tighten the parser so type parameter lists for structs/functions must close with `]` on the same line as the name, rejecting layouts like `struct Box[T` newline `]`. Ensure we emit a clear diagnostic pointing to the stray closing bracket.","status":"closed","priority":3,"issue_type":"task","created_at":"2025-10-24T08:56:49.855138-05:00","updated_at":"2025-10-24T19:51:37.252205-05:00","closed_at":"2025-10-24T19:51:37.252205-05:00"}
{"id":"tea-21","title":"Add docstring support to Tea stdlib","description":"Add descriptive docstrings for Tea's standard library functions and surface them through the compiler/LSP so hover information is available even though the stdlib is not authored in Tea source files. Investigate how to represent, store, and expose doc comments for generated or built-in bindings.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T14:05:55.497469-05:00","updated_at":"2025-10-24T16:05:02.93588-05:00","closed_at":"2025-10-24T16:05:02.93588-05:00"}
{"id":"tea-22","title":"feat: introduce match pattern matching syntax","description":"Add a `match` expression that can branch on both value comparisons and type discriminants. Initial syntax should support matching against literals, identifiers, and wildcards, allowing multi-pattern unions per case (e.g. `case \"y\" | \"yes\"`). Ensure a default `_` arm is supported and evaluate the match expression to the value of the chosen arm.","acceptance_criteria":"- A `match` construct exists with `case` arms returning expressions.\n- Multiple literals can be joined with `|` to share a branch.\n- `_` wildcard matches when no other pattern does.\n- Type-based matches are possible (e.g., variants/structs once implemented) or a plan exists for first-class support.\n- New syntax is documented in `docs/` and covered by compiler tests and `.tea` examples.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-24T19:50:58.85247-05:00","updated_at":"2025-10-25T02:31:26.293141-05:00","closed_at":"2025-10-25T02:31:26.293141-05:00"}
{"id":"tea-23","title":"feat: add const keyword for immutables","description":"Introduce a `const` keyword to define immutable bindings at compile time. Declarations should fail if reassignment is attempted, mirroring Zig's immutable semantics. Update the type checker and runtime representation so constant bindings propagate constness through the pipeline.","acceptance_criteria":"- `const` declarations compile and are enforced as immutable bindings.\n- Reassigning or mutating a `const` binding produces a clear diagnostic.\n- Existing `let` semantics remain unchanged.\n- Document the new keyword in language docs and add `.tea` examples demonstrating correct and failing usage.\n- Compiler tests cover parsing, type checking, and emitted IR/bytecode for const bindings.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-24T19:51:02.230829-05:00","updated_at":"2025-10-24T21:00:56.144082-05:00","closed_at":"2025-10-24T21:00:56.144082-05:00"}
{"id":"tea-24","title":"feat: support string interpolation literals","description":"Add backtick-delimited string literals that allow `${expr}` interpolation inside the literal. Ensure interpolated expressions are evaluated at runtime and concatenated into a single string result. Update the lexer, parser, and runtime string builder to handle this new literal form.","acceptance_criteria":"- Backtick strings (`` `...` ``) parse successfully and permit `${expr}` segments.\n- Interpolated expressions evaluate in place and produce the same value as manual concatenation.\n- Escaping rules are defined for backticks and `${` sequences.\n- Language documentation and `.tea` examples demonstrate interpolated strings.\n- Compiler tests exercise lexing, parsing, and codegen for interpolation.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-24T19:51:05.523242-05:00","updated_at":"2025-10-24T20:32:06.188185-05:00","closed_at":"2025-10-24T20:32:06.188185-05:00"}
{"id":"tea-25","title":"Enums support","description":"Add support for declaring enums in the language, e.g.\n\nenum Color\n  Red\n  Green\n  Blue\nend","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T20:40:37.885385-05:00","updated_at":"2025-10-25T01:34:28.736013-05:00","closed_at":"2025-10-25T01:34:28.736013-05:00"}
{"id":"tea-26","title":"Public vs private functions","description":"Only export functions from modules prefixed with the `pub` keyword.\n\n```\npub def hello(location: String)\n  `Hello #{location`\nend\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T20:59:16.015309-05:00","updated_at":"2025-10-24T23:18:25.154239-05:00","closed_at":"2025-10-24T23:18:25.154239-05:00"}
{"id":"tea-27","title":"Optional values and null","description":"Support optional values that can hold `null` using the `?` suffix syntax.\n\n```\nvar str: String? = null\nstr = \"Hello\"\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T20:59:17.650161-05:00","updated_at":"2025-10-25T11:57:48.915878-05:00","closed_at":"2025-10-25T11:57:48.915878-05:00"}
{"id":"tea-28","title":"Enforce flow-sensitive optional unwrapping","description":"Force `expr!` to type-check only when prior control-flow guarantees the optional is non-nil. Track paths like `if x == nil { return }` so subsequent code can treat `x` as non-optional and emit diagnostics when the unwrap is unsafe.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T23:10:58.701121-05:00","updated_at":"2025-10-24T23:32:22.819618-05:00","closed_at":"2025-10-24T23:32:22.819618-05:00"}
{"id":"tea-29","title":"Implement optional coalesce operator","description":"Add a `??` operator that returns the left operand when it is non-nil, otherwise evaluates and returns the right operand. Ensure it type-checks across optional and non-optional operands, lowers in both VM and AOT backends, and update docs/examples accordingly.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T23:11:11.318796-05:00","updated_at":"2025-10-24T23:47:49.356276-05:00","closed_at":"2025-10-24T23:47:49.356276-05:00"}
{"id":"tea-3","title":"Add std.os module","description":"Add a `std.os` module that provides access to operating-system level facilities. Target capabilities might include:\n- File and directory inspection APIs (metadata, permissions, timestamps)\n- Portable path utilities and environment-specific separators\n- System information queries (platform, architecture, available memory)\n- Process-level helpers like current user/group, locale, and timezone\n- Low-level syscalls or FFI hooks surfaced through safe abstractions.\nFocus on cross-platform behavior first, documenting where functionality may vary by host OS.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-23T22:38:52.906211-05:00","updated_at":"2025-10-24T13:50:39.149706-05:00"}
{"id":"tea-30","title":"Support optional chaining","description":"Introduce optional-chaining syntax (`expr?.prop`, `expr?.call(...)`) that safely navigates optionals without manual nil checks. The chain should short-circuit to nil when any link is nil, type-check against optional receivers, and lower to the VM and LLVM backends. Update docs and add regression examples.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-24T23:11:24.948268-05:00","updated_at":"2025-10-25T01:09:18.544542-05:00","closed_at":"2025-10-25T01:09:18.544542-05:00"}
{"id":"tea-31","title":"Optional values and null","description":"Support optional values that can hold `null` using the `?` suffix syntax.\n\n```\nvar str: String? = null\nstr = \"Hello\"\n```","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-25T12:13:19.60052-05:00","updated_at":"2025-10-25T12:13:40.933575-05:00","closed_at":"2025-10-25T12:13:40.933575-05:00"}
{"id":"tea-32","title":"Replace logical operators with symbols","description":"Update language to use \u0026\u0026 and || instead of the and/or keywords.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-25T15:00:38.060093-05:00","updated_at":"2025-10-25T15:09:19.332634-05:00","closed_at":"2025-10-25T15:09:19.332634-05:00"}
{"id":"tea-33","title":"Refactor enums to use braces","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-25T13:56:43.453626-05:00","updated_at":"2025-10-25T14:43:27.863094-05:00","closed_at":"2025-10-25T14:43:27.863096-05:00"}
{"id":"tea-34","title":"feat: allow match as statement","description":"Expand Tea's match syntax so it can be used as a statement in addition to an expression.\\n\\nGoals:\\n- Permit match blocks where cases omit  and execute statement blocks.\\n- Adjust parser/grammar to recognize statement-form cases and ensure fall-through rules stay explicit.\\n- Update examples and docs to illustrate both expression and statement usage.\\n- Add compiler/runtime tests covering statement-style match control flow.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T09:46:13.600008-05:00","updated_at":"2025-10-26T10:19:39.060823-05:00","closed_at":"2025-10-26T10:19:39.060823-05:00"}
{"id":"tea-35","title":"Add union types with type discrimination","description":"## Summary\n- add a `union` type declaration that aggregates multiple types\n- allow unions to include structs and other unions\n- introduce an `is` type test expression for flow control\n\n## Details\n- update the parser, type checker, and runtime to understand union definitions\n- extend pattern matching to support `case is Type` checks\n- ensure `if value is Type` works for any declared type\n- add language examples and documentation describing the new behavior\n- refresh tree-sitter grammar so tooling recognizes unions and type tests\n\n## Testing\n- add examples covering unions inside match expressions and conditionals\n- extend compiler tests to exercise union definitions and `is` expressions","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T10:43:47.746758-05:00","updated_at":"2025-10-26T10:43:47.749721-05:00","closed_at":"2025-10-26T10:39:36.744183-05:00"}
{"id":"tea-36","title":"Introduce Void return type for empty functions","description":"Currently functions that do not return an explicit value yield Nil, which is still a first-class value used by optionals. Create a new Void type and update the compiler/runtime so implicit-returning functions produce Void instead.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T13:06:35.579214-05:00","updated_at":"2025-10-26T13:49:01.154104-05:00","closed_at":"2025-10-26T13:49:01.154104-05:00"}
{"id":"tea-37","title":"tea-8: parser \u0026 AST for errors-as-values","description":"Extend lexer/parser/AST to recognize  declarations, , , and error union annotations. Ensure resolver registers error types/variants and add design sketch baseline.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T16:42:24.191091-05:00","updated_at":"2025-10-26T22:14:29.968133-05:00","closed_at":"2025-10-26T22:14:29.968133-05:00"}
{"id":"tea-38","title":"tea-8: type system for errors-as-values","description":"Teach the type checker about error variants, function error unions, throw/try/catch semantics, and result propagation so unions compose correctly.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T16:42:29.68505-05:00","updated_at":"2025-10-26T22:14:33.624422-05:00","closed_at":"2025-10-26T22:14:33.624422-05:00"}
{"id":"tea-39","title":"tea-8: runtime \u0026 codegen support for errors-as-values","description":"Update bytecode, VM, and LLVM backend to represent error payloads, propagate throws, and execute try/catch control flow correctly.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T16:42:34.034005-05:00","updated_at":"2025-10-26T22:14:37.005123-05:00","closed_at":"2025-10-26T22:14:37.005123-05:00"}
{"id":"tea-4","title":"Move std.print into std.debug module","description":"Refactor `std.print` into a dedicated `std.debug` module to tighten the standard library organization. Key steps may include:\n- Introducing a `std.debug.print` (or similar) function that re-exports current printing behavior\n- Updating existing imports/usages across examples, tests, and runtime to reference the new module\n- Keeping backwards compatibility where practical, perhaps via a deprecated shim\n- Documenting the new module layout in standard library docs and release notes\nEnsure the move aligns with the emerging module structure and keeps formatting utilities easy to discover.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:42:42.150908-05:00","updated_at":"2025-10-24T13:50:39.149496-05:00","closed_at":"2025-10-24T00:38:24.531056-05:00"}
{"id":"tea-40","title":"tea-8: tooling, tests, and docs for errors-as-values","description":"Refresh tree-sitter grammar, add examples/tests, and document the new error handling model once implementation lands.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-26T16:42:39.124421-05:00","updated_at":"2025-10-26T22:14:40.196834-05:00","closed_at":"2025-10-26T22:14:40.196834-05:00"}
{"id":"tea-41","title":"Add for-of loop for list iteration","description":"Introduce `for \u003citem\u003e of \u003clist\u003e` syntax to iterate over lists, binding a fresh loop variable per element and executing a block until `end`.\n\n## Example Syntax\n```tea\nvar names = [\"Alice\", \"Bob\", \"Charlie\"]\n\nfor person of names\n  debug.print(greet(person))\nend\n```\n\n## Semantics\n- Evaluate list expression once\n- Bind loop variable per element (block-scoped)\n- Execute block for each element\n- Runs zero times if list is empty\n\n## Implementation Areas\n\n### Parser\n- Add `for` statement form: `for identifier of expression block end`\n- Update grammar.ebnf to include for_statement\n\n### Typechecker\n- Require `expression: List[T]`\n- Infer loop variable type as `T`\n- Emit type error for non-list iterables\n\n### Resolver\n- Introduce loop binding scoped to loop body\n- Handle shadowing rules\n\n### Runtime/Codegen\n- Desugar to index-based iteration over list length\n- Generate bytecode for list iteration\n- Support in AOT backend\n\n### Formatter\n- Preserve `for … of` with two-space indentation\n- `end` terminator alignment\n\n### Diagnostics\n- Clear errors for non-list iterables\n- Clear errors for invalid loop targets\n\n### Documentation \u0026 Examples\n- Add `examples/language/control_flow/for.tea`\n- Update grammar specification\n- Update language reference docs\n\n## Out of Scope (v1)\n- `break`/`continue` statements\n- Multi-binding or destructuring (e.g., `for key, value`)\n- Non-list iterables (dicts, strings, ranges)\n- List comprehensions\n\n## Open Questions\n1. Should it support dict iteration as key/value pairs?\n2. Should it support string iteration as characters?\n3. Should it support ranges (via `range(start, end)`)?\n4. Should we add an `enumerate` form for index + value?\n5. Should loop variable be read-only (immutable)?\n6. Should we permit shadowing of outer variables?\n\n## Recommendations\n- **v1**: Lists only, read-only loop variable\n- **Future**: Dict key/value pairs, string chars, ranges, enumerate via separate issues","design":"## Syntax Design\n```ebnf\nfor_statement = \"for\" identifier \"of\" expression block \"end\" ;\n```\n\nAligns with existing control flow (`while`, `until`, `unless`) using `end` terminator.\n\n## Type System\n- Expression must be `List[T]` for some type `T`\n- Loop variable has type `T` (inferred from list element type)\n- Loop variable is block-scoped, immutable\n\n## Execution Model\nDesugar to:\n```\nvar __list = \u003cexpression\u003e\nvar __index = 0\nwhile __index \u003c list.length(__list)\n  var \u003cidentifier\u003e = __list[__index]\n  \u003cblock\u003e\n  __index = __index + 1\nend\n```\n\n## Error Cases\n- Non-list iterable: \"Cannot iterate over type X, expected List[T]\"\n- Invalid binding target: handled by parser","acceptance_criteria":"- Parses `for \u003cvar\u003e of \u003clist\u003e ... end` syntax correctly\n- Formats for-of loops with proper indentation\n- Typechecks: loop var type equals list element type\n- Rejects non-list iterables with clear error message\n- Executes correctly for non-empty lists\n- Executes correctly for empty lists (zero iterations)\n- New example file `examples/language/control_flow/for.tea` runs successfully\n- Tree-sitter grammar recognizes for-of syntax\n- Parser tests cover for-of statements\n- Runtime tests verify iteration behavior\n- Type checker tests verify List[T] constraint","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-27T20:56:47.725076-05:00","updated_at":"2025-10-27T21:12:17.504794-05:00","closed_at":"2025-10-27T21:12:17.504794-05:00"}
{"id":"tea-42","title":"Eliminate unnecessary parameter stack allocations","description":"Function parameters are currently stored to stack and immediately loaded back, causing unnecessary memory traffic and preventing register allocation.\n\n**Current IR:**\n```llvm\ndefine i64 @sum_to_n(i64 %n) {\n  %n1 = alloca i64          ; ← Unnecessary allocation\n  store i64 %n, ptr %n1\n  ...\n  %n3 = load i64, ptr %n1   ; ← Load from stack\n}\n```\n\n**Goal:**\n- Keep immutable parameters in SSA registers\n- Only allocate stack space for mutable variables\n- Track mutability in LocalVariable struct\n\n**Impact:** 10-30% speedup on function-heavy code","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-10-28T18:40:58.950948-05:00","updated_at":"2025-10-28T18:57:05.406283-05:00","closed_at":"2025-10-28T18:57:05.406283-05:00"}
{"id":"tea-43","title":"Stack-allocate small collections","description":"All strings, lists, and dicts are currently heap-allocated via FFI calls, even when small and fixed-size.\n\n**Optimization:**\n- Inline small strings (\u003c 24 bytes) on stack\n- Inline small lists (\u003c 8 elements) on stack\n- Use LLVM struct values instead of pointers\n- Inline simple operations (len, get) without FFI\n\n**Impact:** 20-50% speedup on collection-heavy code\n**Note:** This is a complex optimization requiring significant codegen changes","design":"## Current State\nAll collections (strings, lists, dicts) are heap-allocated via FFI calls to tea-runtime:\n- Strings: `tea_alloc_string(ptr, len)` → `Box\u003cTeaString\u003e`\n- Lists: `tea_alloc_list(len)` → `Box\u003cTeaList\u003e` \n- Dicts: `tea_dict_new()` → `Box\u003cTeaDict\u003e`\n\n## Small String Optimization Design\nCreate stack-allocated string representation for strings \u003c 24 bytes:\n\n```llvm\n; Small string struct (24 bytes total on x64)\n%SmallString = type {\n  i8,      ; tag: 0=heap, 1=inline\n  i8,      ; length (0-22)\n  [22 x i8] ; inline data\n}\n\n; Heap string struct (16 bytes)\n%HeapString = type {\n  i8,      ; tag: 0\n  i8,      ; padding\n  i64,     ; length\n  ptr      ; data pointer\n}\n```\n\n**Implementation:**\n- At compile time, check if string literal length \u003c 23\n- If small: allocate `SmallString` on stack, set tag=1, copy bytes inline\n- If large: use existing heap allocation\n- Inline `len()` operation: check tag, return inline length or heap length\n- Inline `get()` operation: check tag, index into inline data or heap data\n\n## Small List Optimization Design\nCreate stack-allocated list for lists with \u003c 8 elements:\n\n```llvm\n; Small list struct (72 bytes on x64)\n%SmallList = type {\n  i8,      ; tag: 0=heap, 1=inline\n  i8,      ; length (0-7)\n  [8 x %TeaValue] ; inline elements (64 bytes)\n}\n\n; Heap list struct (24 bytes)\n%HeapList = type {\n  i8,      ; tag: 0\n  i8,      ; padding\n  i64,     ; length\n  i64,     ; capacity\n  ptr      ; items pointer\n}\n```\n\n**Implementation:**\n- At compile time, check if list literal has \u003c 8 elements\n- If small: allocate `SmallList` on stack, set tag=1, initialize inline elements\n- If large: use existing heap allocation\n- Inline `len()`: check tag, return inline count or heap count\n- Inline `get(i)`: check tag, index into inline array or heap array\n\n## Dict Optimization\nDicts remain heap-allocated (HashMap complexity requires heap). However, inline common operations:\n- Inline `len()`: directly access `dict.entries.len()` without FFI\n- Cache dict pointer instead of reloading\n\n## Implementation Strategy\n1. Add new LLVM struct types for SmallString and SmallList\n2. Modify `compile_string_literal()` to choose inline vs heap based on size\n3. Modify `compile_list_literal()` to choose inline vs heap based on element count\n4. Add helper methods `inline_string_len()`, `inline_list_len()`, `inline_list_get()`\n5. Update `load_from_pointer()` to handle tagged union types\n6. Update runtime operations to handle both representations\n\n## Compatibility\n- Keep existing runtime FFI functions for large collections\n- Tagged union ensures both paths work correctly\n- No ABI changes needed for function signatures (still use %TeaValue)\n\n## Performance Impact\n- Small strings: eliminate FFI call + heap allocation (20-50% faster)\n- Small lists: eliminate FFI call + heap allocation (20-50% faster)\n- Inlined operations: avoid FFI overhead (2-5x faster for len/get)","status":"open","priority":1,"issue_type":"feature","created_at":"2025-10-28T18:41:02.461204-05:00","updated_at":"2025-10-29T21:33:01.48739-05:00"}
{"id":"tea-44","title":"Add inlining hints for small pure functions","description":"LLVM doesn't have enough information to aggressively inline small functions.\n\n**Add attributes:**\n- `alwaysinline` for functions \u003c 10 LLVM instructions\n- `inlinehint` for pure functions without side effects\n- Consider function size and purity during codegen\n\n**Impact:** 5-15% speedup across the board\n**Complexity:** Low - just need to add attributes based on function analysis","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-28T18:41:03.867366-05:00","updated_at":"2025-10-28T19:07:12.617917-05:00","closed_at":"2025-10-28T19:07:12.617917-05:00"}
{"id":"tea-45","title":"Implement tail call optimization","description":"Recursive functions don't use tail calls, limiting recursion depth and missing optimization opportunities.\n\n**Implementation:**\n- Detect tail-recursive call patterns\n- Add `musttail` attribute to tail calls\n- Consider transforming tail recursion to loops\n\n**Impact:** Enables deep recursion (constant stack), same runtime performance\n**Benefit:** Unlocks patterns that would otherwise stack overflow","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-28T18:41:06.323952-05:00","updated_at":"2025-10-28T19:12:05.802969-05:00","closed_at":"2025-10-28T19:12:05.802969-05:00"}
{"id":"tea-46","title":"Add constant folding in codegen","description":"Some compile-time constants are evaluated at runtime instead of being folded during codegen.\n\n**Optimize:**\n- Fold constant arithmetic at compile time\n- Pre-compute string concatenations of literals\n- Cache frequently used constant values\n\n**Impact:** 2-5% speedup\n**Complexity:** Low - add constant evaluation during expression compilation","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-28T18:41:09.016127-05:00","updated_at":"2025-10-28T19:08:00.165268-05:00","closed_at":"2025-10-28T19:08:00.165268-05:00"}
{"id":"tea-47","title":"Improve memory-to-register promotion for top-level bindings","description":"Top-level const/var bindings use global memory instead of registers, preventing optimization.\n\n**Current:**\n```llvm\nstore i64 0, ptr @.binding.i, align 4  ; ← Global memory\n%i = load i64, ptr @.binding.i, align 4\n```\n\n**Fix:**\n- Allocate top-level vars on stack in main\n- Pass as parameters to functions when needed\n- Use thread-local storage for true globals\n\n**Impact:** 5-10% speedup","status":"open","priority":3,"issue_type":"feature","created_at":"2025-10-28T18:41:10.933123-05:00","updated_at":"2025-10-28T18:41:10.933123-05:00"}
{"id":"tea-48","title":"Add loop metadata for vectorization","description":"Add LLVM metadata to loops to enable better optimization and vectorization.\n\n**Add metadata:**\n- `!llvm.loop` metadata with unroll hints\n- `!range` metadata for loop bounds\n- `!invariant.load` for immutable reads\n- Vectorization hints where applicable\n\n**Impact:** 0-5% (might enable auto-vectorization in some cases)\n**Complexity:** Low - add metadata during loop codegen","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-10-28T18:41:13.200808-05:00","updated_at":"2025-10-28T19:30:21.295762-05:00","closed_at":"2025-10-28T19:30:21.295762-05:00"}
{"id":"tea-49","title":"Enable LLVM Link-Time Optimization (LTO)","description":"Add support for LTO to enable cross-module optimization during linking.\n\n**Implementation:**\n- Add `--lto` flag (thin/full)\n- Pass LTO flags to rustc during linking\n- Enable cross-module inlining and optimization\n\n**Impact:** 5-10% speedup (with slower compile time)\n**Trade-off:** Compilation time increases significantly","notes":"Added --lto flag to CLI. However, full LTO support requires LLVM bitcode to be embedded in Tea object files, which needs more complex implementation. Current implementation only enables LTO for Rust runtime code. Marking as blocked pending bitcode emission support.","status":"blocked","priority":3,"issue_type":"feature","created_at":"2025-10-28T18:41:15.742531-05:00","updated_at":"2025-10-28T19:20:38.553557-05:00"}
{"id":"tea-5","title":"Add GitHub Action for PR builds","description":"Introduce GitHub Actions CI coverage for pull requests to ensure build and test checks run automatically. An initial workflow could:\n- Trigger on `pull_request` (and optionally `push` to main branches)\n- Install required toolchains (Rust stable, LLVM dependencies)\n- Run `cargo fmt --check`, `cargo clippy` (if configured), and `cargo test --workspace`\n- Invoke `cargo run -p tea-cli -- test --fail-fast` and `scripts/e2e.sh` where feasible\n- Cache build artifacts to speed up subsequent runs and upload sanitized logs on failure.\nDocument the workflow expectations so contributors understand the gates before merging.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:59:19.912801-05:00","updated_at":"2025-10-24T13:50:39.149217-05:00","closed_at":"2025-10-24T00:38:27.777389-05:00"}
{"id":"tea-50","title":"Add Profile-Guided Optimization (PGO) support","description":"Implement PGO to optimize based on real-world program behavior.\n\n**Implementation:**\n- Add `--pgo-instrument` flag to generate instrumented binary\n- Add `--pgo-use=profile.data` flag to use profile data\n- Pass PGO flags through to LLVM and rustc\n\n**Impact:** 10-20% speedup for real workloads\n**Workflow:**\n1. Build with `--pgo-instrument`\n2. Run representative workload\n3. Rebuild with `--pgo-use` for optimal performance","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-10-28T18:41:18.917297-05:00","updated_at":"2025-10-29T21:37:10.989771-05:00","closed_at":"2025-10-29T21:37:10.989771-05:00"}
{"id":"tea-51","title":"Implement custom memory allocator","description":"Replace default allocator with specialized allocators for different allocation patterns.\n\n**Allocator strategies:**\n- Arena allocator for temporary objects\n- Bump allocator for linear access patterns\n- Pool allocator for fixed-size objects (strings, list nodes)\n- Thread-local allocation pools\n\n**Impact:** 5-15% speedup for allocation-heavy code\n**Complexity:** High - requires runtime changes","status":"open","priority":3,"issue_type":"feature","created_at":"2025-10-28T18:41:21.182877-05:00","updated_at":"2025-10-28T18:41:21.182877-05:00"}
{"id":"tea-52","title":"Add specialized fast paths for primitive operations","description":"Avoid FFI and boxing overhead for primitive type operations.\n\n**Optimizations:**\n- Inline `+` operator for Int/Float (no FFI call)\n- Inline `len()` for arrays (direct field access)\n- Avoid boxing arithmetic results\n- Use native LLVM operations directly\n\n**Impact:** 30-50% speedup for arithmetic-heavy code\n**Complexity:** Medium - requires recognizing patterns and generating specialized code","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-10-28T18:41:23.629592-05:00","updated_at":"2025-10-28T19:02:58.541735-05:00","closed_at":"2025-10-28T19:02:58.541735-05:00"}
{"id":"tea-53","title":"Add SIMD vectorization support","description":"Leverage SIMD instructions for data-parallel operations.\n\n**Implementation:**\n- Auto-vectorize loops where possible\n- Add SIMD intrinsics for math operations\n- Use LLVM's SLP vectorizer hints\n- Add explicit vectorization pragmas/attributes\n\n**Impact:** 2-8x speedup for data-parallel code (arrays, matrices)\n**Complexity:** High - requires sophisticated loop analysis","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-10-28T18:41:25.47106-05:00","updated_at":"2025-10-29T21:41:56.867828-05:00","closed_at":"2025-10-29T21:41:56.867828-05:00"}
{"id":"tea-54","title":"Add loop metadata for vectorization","description":"Add LLVM metadata to loops to enable better optimization and vectorization.\n\n**Add metadata:**\n- `!llvm.loop` metadata with unroll hints\n- `!range` metadata for loop bounds\n- `!invariant.load` for immutable reads\n- Vectorization hints where applicable\n\n**Impact:** 0-5% (might enable auto-vectorization in some cases)\n**Complexity:** Low - add metadata during loop codegen","status":"closed","priority":3,"issue_type":"feature","created_at":"2025-10-28T19:51:40.339383-05:00","updated_at":"2025-10-29T21:31:08.182582-05:00","closed_at":"2025-10-29T21:31:08.182582-05:00"}
{"id":"tea-55","title":"Optimize AOT compiler to match Rust performance","description":"The Tea AOT compiler currently generates binaries that are 1.17x to 57.8x slower than equivalent Rust code. Analysis shows this is due to specific code generation issues that can be fixed:\n\n**Current Performance:**\n- loops: 111ms (57.8x slower than Rust's 1.9ms)\n- strings: 30ms (14.9x slower than Rust's 2ms)\n- math: 26ms (7.2x slower than Rust's 3.7ms)\n- dicts: 19.5ms (3.3x slower than Rust's 6ms)\n- fib: 206ms (1.17x slower than Rust's 176ms) ✅\n\n**Root Causes:**\n1. Loop variables use stack allocations (load/store) instead of SSA registers (PHI nodes)\n2. Top-level variables use global memory instead of stack/registers\n3. Primitive operations call FFI runtime instead of inline LLVM instructions\n\n**Target:** Match or exceed Rust performance on all benchmarks","design":"## Design\n\n### Phase 1: Use SSA for Immutable Variables (Target: 50x speedup on loops)\n\n**Current LLVM IR:**\n```llvm\ndefine i64 @sum_to_n(i64 %n) {\n  %i = alloca i64           ; ← Stack allocation\n  %total = alloca i64\n  store i64 0, ptr %total\n  store i64 1, ptr %i\n  \n  loop_body:\n    %total2 = load i64, ptr %total  ; ← 4 loads + 2 stores per iteration\n    %i3 = load i64, ptr %i\n    %addtmp = add i64 %total2, %i3\n    store i64 %addtmp, ptr %total\n}\n```\n\n**Target LLVM IR:**\n```llvm\ndefine i64 @sum_to_n(i64 %n) {\n  br label %loop_cond\n\nloop_cond:\n  %i.phi = phi i64 [ 1, %entry ], [ %i.next, %loop_body ]\n  %total.phi = phi i64 [ 0, %entry ], [ %total.next, %loop_body ]\n  ; ... no memory operations!\n\nloop_body:\n  %total.next = add i64 %total.phi, %i.phi    ; ← Pure register ops\n  %i.next = add i64 %i.phi, 1\n}\n```\n\n**Implementation:**\n\n1. Modify `LocalVariable` usage to distinguish mutable vs immutable:\n   - Immutable: Store `value` (SSA), leave `pointer` as None\n   - Mutable: Store `pointer`, leave `value` as None\n\n2. In `compile_var_statement`:\n   - Check `var_stmt.is_const` or use `find_mutated_in_statements`\n   - For immutable: Store SSA value directly\n   - For mutable: Allocate stack space\n\n3. In `compile_loop_statement`:\n   - Use PHI nodes for loop variables\n   - Track SSA values across loop iterations\n\n4. In `compile_identifier_expression`:\n   - For immutable vars: Return SSA value directly\n   - For mutable vars: Load from pointer\n\n### Phase 2: Move Globals to Stack\n\n1. In `compile_main`:\n   - Allocate stack space for top-level vars\n   - Pass as arguments to functions if needed\n   - Or use SSA for const globals\n\n### Phase 3: Inline Primitive Operations\n\n1. String concatenation: Detect small constant strings, fold at compile-time\n2. Arithmetic: Already inlined, ensure no unnecessary boxing\n3. Collection operations: Inline len(), get() for small fixed-size collections\n\n**Code Locations:**\n- `tea-compiler/src/aot/mod.rs:480-490` (LocalVariable struct)\n- `tea-compiler/src/aot/mod.rs:1462-1520` (Loop compilation)\n- `tea-compiler/src/aot/mod.rs:1787-1810` (Global variables)\n- `tea-compiler/src/aot/mod.rs:1152-1237` (Function parameters)","acceptance_criteria":"## Acceptance Criteria\n\n### Phase 1: SSA for Immutable Variables\n- [ ] Immutable local variables use SSA values (no alloca/load/store)\n- [ ] Loop variables use PHI nodes\n- [ ] Function parameters that aren't mutated use SSA\n- [ ] Loops benchmark: \u003c 5ms (down from 111ms, target: ~2ms to match Rust)\n- [ ] All tests pass\n\n### Phase 2: Stack Locals\n- [ ] Top-level variables allocated on stack in main\n- [ ] No global variables for mutable bindings\n- [ ] All benchmarks improve by 2-3x\n\n### Phase 3: Inline Primitives\n- [ ] Arithmetic operations fully inlined (no FFI)\n- [ ] Small string operations optimized\n- [ ] Math benchmark: \u003c 5ms (down from 26ms)\n- [ ] Strings benchmark: \u003c 5ms (down from 30ms)\n\n### Overall Success\n- [ ] All benchmarks within 2x of Rust (minimum)\n- [ ] At least 3 benchmarks match or beat Rust (target)\n- [ ] No performance regression on fib benchmark\n- [ ] Generated LLVM IR shows PHI nodes in loops\n- [ ] Generated LLVM IR shows no unnecessary memory operations","status":"in_progress","priority":1,"issue_type":"task","assignee":"assistant","created_at":"2025-10-29T22:37:41.116095-05:00","updated_at":"2025-10-29T22:37:47.083076-05:00"}
{"id":"tea-6","title":"Create Language Server Protocol implementation","description":"Build an LSP server for Tea to bring editor integration up to par. Initial feature set should prioritize:\n- Syntax-aware diagnostics surfaced as users type (compilation errors, lexical issues)\n- Go-to-definition, hover tooltips, and symbol lookup based on the compiler’s semantic model\n- Formatting hooks that leverage `tea-cli fmt`\n- Incremental analysis and caching so feedback stays responsive on larger projects\n- Extensible architecture for future features such as inline evaluation or refactorings.\nDocument setup instructions for popular editors (VS Code, Neovim, Helix) and provide demos or GIFs once functional.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:59:25.669345-05:00","updated_at":"2025-10-24T23:21:42.391829-05:00","closed_at":"2025-10-24T23:21:42.391829-05:00"}
{"id":"tea-7","title":"Emit compiler warnings for bad code practices","description":"Enhance the compiler to detect and report common code hygiene issues. Focus areas could include:\n- Unused imports, variables, and function arguments\n- Deprecated APIs or language constructs\n- Shadowed bindings that may hide outer scope values\n- Suspicious control flow, such as unreachable code or always-true conditions\n- Configurable warning levels and suppression annotations so advanced users can opt out selectively.\nUpdate tests and docs to establish the new linting expectations and provide guidance on resolving warnings.","status":"open","priority":2,"issue_type":"task","created_at":"2025-10-23T22:59:30.641195-05:00","updated_at":"2025-10-24T13:50:39.148827-05:00"}
{"id":"tea-8","title":"Adopt errors-as-values pattern","description":"Rework error handling so Tea programs can treat errors as first-class values. Key steps could include:\n- Introducing a lightweight result type (e.g., `Result\u003cT, E\u003e`) or equivalent pattern in the language\n- Refactoring the standard library to expose fallible operations via explicit error returns instead of panics or implicit exceptions\n- Updating core language constructs (pattern matching, async) to interoperate smoothly with the new error model\n- Providing ergonomics for error propagation, aggregation, and formatting\n- Documenting migration guidance and updating examples/tests to showcase idiomatic usage.\nEnsure runtime semantics stay predictable and compiler diagnostics guide users toward the new APIs.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-10-23T22:59:34.686238-05:00","updated_at":"2025-10-26T22:14:43.46611-05:00","closed_at":"2025-10-26T22:14:43.46611-05:00"}
{"id":"tea-9","title":"Stand up first-class Tea language server","description":"","notes":"Deliver a robust Tea language server that offers diagnostics, editing assists, and workspace awareness for editors like Neovim and VS Code. Track enhancements across parsing, type analysis, and tooling integration so the LSP becomes a reliable daily driver.","status":"closed","priority":2,"issue_type":"epic","created_at":"2025-10-24T01:11:42.214913-05:00","updated_at":"2025-10-24T16:49:14.470904-05:00","closed_at":"2025-10-24T16:49:14.470904-05:00"}
