#!/usr/bin/env node

const fs = require("node:fs");
const path = require("node:path");
const yaml = require("yaml");

const AST_YAML_PATH = path.join(__dirname, "../spec/ast.yaml");
const OUTPUT_PATH = path.join(__dirname, "../tea-compiler/src/ast.rs");

function toRustType(typeStr) {
  if (!typeStr) return "Unknown";

  // Already a valid Rust type
  return typeStr;
}

function toSnakeCase(str) {
  return str
    .replace(/([A-Z])/g, "_$1")
    .toLowerCase()
    .replace(/^_/, "");
}

function generateNode(name, node) {
  const lines = [];

  if (node.description) {
    lines.push(`/// ${node.description}`);
  }

  // Handle derives
  const derives = node.derives || ["Debug", "Clone"];
  lines.push(`#[derive(${derives.join(", ")})]`);

  if (node.variants) {
    // Generate enum
    lines.push(`pub enum ${name} {`);

    node.variants.forEach((variant) => {
      if (typeof variant === "string") {
        lines.push(`    ${variant},`);
      } else {
        const [variantName, variantData] = Object.entries(variant)[0];

        if (variantData.description) {
          lines.push(`    /// ${variantData.description}`);
        }

        // Check if it's a simple tuple variant
        if (variantData.type) {
          lines.push(`    ${variantName}(${toRustType(variantData.type)}),`);
        } else if (variantData.fields && Array.isArray(variantData.fields)) {
          // Multi-field tuple variant
          const fieldTypes = variantData.fields
            .map((f) => toRustType(f))
            .join(", ");
          lines.push(`    ${variantName}(${fieldTypes}),`);
        } else {
          // Struct variant
          lines.push(`    ${variantName} {`);
          for (const [fieldName, fieldValue] of Object.entries(variantData)) {
            if (fieldName === "description") continue;
            const rustType = toRustType(fieldValue);
            lines.push(`        ${toSnakeCase(fieldName)}: ${rustType},`);
          }
          lines.push(`    },`);
        }
      }
    });

    lines.push("}");
  } else if (node.fields) {
    // Generate struct
    lines.push(`pub struct ${name} {`);

    for (const [fieldName, fieldInfo] of Object.entries(node.fields)) {
      if (typeof fieldInfo === "object" && fieldInfo.description) {
        lines.push(`    /// ${fieldInfo.description}`);
      }

      const fieldType =
        typeof fieldInfo === "object" ? fieldInfo.type : fieldInfo;
      const rustType = toRustType(fieldType);

      lines.push(`    pub ${toSnakeCase(fieldName)}: ${rustType},`);
    }

    lines.push("}");
  }

  return lines.join("\n");
}

function generateAST() {
  const astContent = fs.readFileSync(AST_YAML_PATH, "utf-8");
  const ast = yaml.parse(astContent);

  const lines = [];

  lines.push("// AUTO-GENERATED from spec/ast.yaml");
  lines.push(
    "// Do not edit this file directly - run `bun run codegen` to regenerate",
  );
  lines.push("");
  lines.push("#![allow(dead_code)]");
  lines.push("");
  lines.push("use crate::lexer::Token;");
  lines.push("");

  // Generate all nodes in order
  for (const [nodeName, nodeData] of Object.entries(ast.nodes)) {
    lines.push(generateNode(nodeName, nodeData));
    lines.push("");

    // Add impl blocks for specific types
    if (nodeName === "SourceSpan") {
      lines.push("impl SourceSpan {");
      lines.push(
        "    pub fn new(line: usize, column: usize, end_line: usize, end_column: usize) -> Self {",
      );
      lines.push("        Self {");
      lines.push("            line,");
      lines.push("            column,");
      lines.push("            end_line,");
      lines.push("            end_column,");
      lines.push("        }");
      lines.push("    }");
      lines.push("");
      lines.push(
        "    pub fn single_point(line: usize, column: usize) -> Self {",
      );
      lines.push("        Self::new(line, column, line, column)");
      lines.push("    }");
      lines.push("");
      lines.push("    pub fn union(a: &Self, b: &Self) -> Self {");
      lines.push("        if a.line == 0 {");
      lines.push("            return *b;");
      lines.push("        }");
      lines.push("        if b.line == 0 {");
      lines.push("            return *a;");
      lines.push("        }");
      lines.push("");
      lines.push("        let (start_line, start_column) =");
      lines.push(
        "            if (a.line < b.line) || (a.line == b.line && a.column <= b.column) {",
      );
      lines.push("                (a.line, a.column)");
      lines.push("            } else {");
      lines.push("                (b.line, b.column)");
      lines.push("            };");
      lines.push("");
      lines.push(
        "        let (end_line, end_column) = if (a.end_line > b.end_line)",
      );
      lines.push(
        "            || (a.end_line == b.end_line && a.end_column >= b.end_column)",
      );
      lines.push("        {");
      lines.push("            (a.end_line, a.end_column)");
      lines.push("        } else {");
      lines.push("            (b.end_line, b.end_column)");
      lines.push("        };");
      lines.push("");
      lines.push(
        "        Self::new(start_line, start_column, end_line, end_column)",
      );
      lines.push("    }");
      lines.push("}");
      lines.push("");
      lines.push("impl Default for SourceSpan {");
      lines.push("    fn default() -> Self {");
      lines.push("        Self {");
      lines.push("            line: 0,");
      lines.push("            column: 0,");
      lines.push("            end_line: 0,");
      lines.push("            end_column: 0,");
      lines.push("        }");
      lines.push("    }");
      lines.push("}");
      lines.push("");
    } else if (nodeName === "Module") {
      lines.push("impl Module {");
      lines.push("    pub fn new(statements: Vec<Statement>) -> Self {");
      lines.push("        Self { statements }");
      lines.push("    }");
      lines.push("}");
      lines.push("");
    }
  }

  const output = lines.join("\n");
  
  // Ensure output directory exists
  const outDir = path.dirname(OUTPUT_PATH);
  fs.mkdirSync(outDir, { recursive: true });
  
  fs.writeFileSync(OUTPUT_PATH, output, "utf-8");
  
  // Format the generated file with rustfmt
  const { execSync } = require('child_process');
  try {
    execSync(`rustfmt ${OUTPUT_PATH}`, { stdio: 'inherit' });
  } catch (error) {
    console.warn('Warning: rustfmt failed, but file was generated');
  }
  
  console.log(`âœ“ Generated ${OUTPUT_PATH}`);
}

try {
  generateAST();
} catch (error) {
  console.error("Error generating AST:", error.message);
  console.error(error.stack);
  process.exit(1);
}
