#!/usr/bin/env node

const fs = require("node:fs");
const path = require("node:path");
const toml = require("toml");

const TOKENS_PATH = path.join(__dirname, "../spec/tokens.toml");
const OUTPUT_PATH = path.join(
  __dirname,
  "../tree-sitter-tea/queries/highlights.scm",
);

function generateHighlights() {
  const tokensContent = fs.readFileSync(TOKENS_PATH, "utf-8");
  const tokens = toml.parse(tokensContent);

  const lines = [];

  lines.push("; AUTO-GENERATED from spec/tokens.toml");
  lines.push(
    "; Do not edit this file directly - run `bun run codegen` to regenerate",
  );
  lines.push("");

  // Generate safe keywords array
  lines.push("; Keywords");
  lines.push("[");
  tokens.tree_sitter.safe_keywords.forEach((kw) => {
    lines.push(`  "${kw}"`);
  });
  lines.push("] @keyword");
  lines.push("");

  // Generate contextual keywords
  tokens.tree_sitter.contextual_keywords.forEach(({ node, keyword }) => {
    lines.push(`(${node}`);
    lines.push(`  "${keyword}" @keyword)`);
    lines.push("");
  });

  // Generate node-type based highlights
  lines.push("(function_definition");
  lines.push("  name: (identifier) @function)");
  lines.push("");

  lines.push("(function_definition");
  lines.push("  return_type: (_) @type)");
  lines.push("");

  lines.push("(error_type");
  lines.push("  name: (identifier) @type)");
  lines.push("");

  lines.push("(error_type");
  lines.push("  variant: (identifier) @constructor)");
  lines.push("");

  lines.push("(struct_definition");
  lines.push("  name: (identifier) @type)");
  lines.push("");

  lines.push("(enum_definition");
  lines.push("  name: (identifier) @type)");
  lines.push("");

  lines.push("(error_definition");
  lines.push("  name: (identifier) @type)");
  lines.push("");

  lines.push("(error_variant");
  lines.push("  name: (identifier) @constructor)");
  lines.push("");

  lines.push("(error_field");
  lines.push("  name: (identifier) @property)");
  lines.push("");

  lines.push("(parameter");
  lines.push("  name: (identifier) @variable.parameter)");
  lines.push("");

  lines.push("(parameter");
  lines.push("  type: (_) @type)");
  lines.push("");

  lines.push("(type_annotation");
  lines.push("  (identifier) @type)");
  lines.push("");

  lines.push("(call_expression");
  lines.push("  function: (identifier) @function.call)");
  lines.push("");

  lines.push("(member_expression");
  lines.push("  property: (identifier) @property)");
  lines.push("");

  lines.push("(var_declaration");
  lines.push("  name: (identifier) @variable)");
  lines.push("");

  lines.push("(const_declaration");
  lines.push("  name: (identifier) @constant)");
  lines.push("");

  lines.push("(use_statement");
  lines.push("  alias: (identifier) @namespace)");
  lines.push("");

  lines.push("(catch_clause");
  lines.push("  binding: (identifier) @variable)");
  lines.push("");

  // Literals
  lines.push("[");
  lines.push("  (string)");
  lines.push("  (template_string)");
  lines.push("] @string");
  lines.push("");

  lines.push("(number) @number");
  lines.push("");

  lines.push("(boolean) @boolean");
  lines.push("");

  lines.push("(nil) @constant.builtin");
  lines.push("");

  lines.push("(comment) @comment");
  lines.push("");

  const output = lines.join("\n");
  
  // Ensure output directory exists
  const outDir = path.dirname(OUTPUT_PATH);
  fs.mkdirSync(outDir, { recursive: true });
  
  fs.writeFileSync(OUTPUT_PATH, output, "utf-8");
  console.log(`âœ“ Generated ${OUTPUT_PATH}`);
}

try {
  generateHighlights();
} catch (error) {
  console.error("Error generating highlights.scm:", error.message);
  process.exit(1);
}
