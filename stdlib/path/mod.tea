# Path manipulation utilities for working with file paths.
#
# PROGRESS: As of 2025-10-31, most path functions are now implemented in pure Tea!
#
# Pure Tea implementations:
#   ✓ join() - concatenates path components
#   ✓ components() - splits path by separator
#   ✓ basename() - extracts filename
#   ✓ dirname() - extracts directory
#   ✓ extension() - extracts file extension
#   ✓ normalize() - resolves . and .. components
#
# Remaining intrinsics (require OS interaction or platform-specific logic):
#   - separator() - platform-specific ("/" vs "\")
#   - absolute() - requires OS interaction to resolve current directory
#   - relative() - complex path resolution logic

use intrinsics = "std.intrinsics"

# Internal helper to remove trailing separators from a path.
# Returns empty string if path is all separators.
def trim_trailing_separators(file_path: String) -> String
  var sep = intrinsics.path_separator()
  var len = @len(file_path)
  var end_pos = len

  while end_pos > 0
    var char = file_path[end_pos - 1]

    if char == sep
      end_pos = end_pos - 1
    else
      # Found a non-separator, stop here
      return file_path[0..end_pos]
    end
  end

  # All separators
  ""
end

# Join path components into a single path.
#
# Examples:
#   var path = path.join(["usr", "local", "bin"])  # => "usr/local/bin"
#
# Pure Tea implementation - builds path by concatenating components with separator.
pub def join(parts: List[String]) -> String
  if @len(parts) == 0
    return ""
  end

  var result = parts[0]
  var sep = intrinsics.path_separator()
  var i = 1

  while i < @len(parts)
    result = result + sep + parts[i]
    i = i + 1
  end

  result
end

# Split a path into its components.
#
# Examples:
#   var parts = path.components("/usr/local/bin")  # => ["usr", "local", "bin"]
#   var parts = path.components("usr/local/")  # => ["usr", "local"]
#
# Pure Tea implementation - splits by separator and filters empty strings.
pub def components(file_path: String) -> List[String]
  if @len(file_path) == 0
    return[]
  end

  var sep = intrinsics.path_separator()
  var all_parts = intrinsics.string_split(file_path, sep)
  var result = []
  var i = 0

  while i < @len(all_parts)
    var part = all_parts[i]

    if @len(part) > 0
      result = result +[part]
    end

    i = i + 1
  end

  result
end

# Get the directory part of a path.
#
# Examples:
#   var dir = path.dirname("/usr/local/bin/tea")  # => "/usr/local/bin"
#   var dir = path.dirname("/usr/local/")  # => "/usr/local"
#   var dir = path.dirname("file.txt")  # => ""
#   var dir = path.dirname("/")  # => "/"
#
# Pure Tea implementation - finds last separator and returns everything before it.
pub def dirname(file_path: String) -> String
  if @len(file_path) == 0
    return ""
  end

  var sep = intrinsics.path_separator()
  var trimmed = trim_trailing_separators(file_path)

  # Handle root path
  if @len(trimmed) == 0
    return sep
  end

  var last_sep = intrinsics.string_index_of(trimmed, sep)
  var pos = last_sep
  var i = last_sep + 1

  # Find the last occurrence of separator
  while i < @len(trimmed)
    var next_pos = intrinsics.string_index_of(trimmed[i...@len(trimmed)], sep)

    if next_pos >= 0
      pos = i + next_pos
      i = pos + 1
    else
      i = @len(trimmed)
    end
  end

  # No separator found
  if pos < 0
    return ""
  end

  # Root path
  if pos == 0
    return sep
  end

  trimmed[0..pos]
end

# Get the filename part of a path.
#
# Examples:
#   var name = path.basename("/usr/local/bin/tea")  # => "tea"
#   var name = path.basename("/usr/local/")  # => "local"
#   var name = path.basename("file.txt")  # => "file.txt"
#   var name = path.basename("/")  # => ""
#
# Pure Tea implementation - returns everything after the last separator.
pub def basename(file_path: String) -> String
  if @len(file_path) == 0
    return ""
  end

  var sep = intrinsics.path_separator()
  var trimmed = trim_trailing_separators(file_path)

  # Handle root path
  if @len(trimmed) == 0
    return ""
  end

  var last_sep = intrinsics.string_index_of(trimmed, sep)
  var pos = last_sep
  var i = last_sep + 1

  # Find the last occurrence of separator
  while i < @len(trimmed)
    var next_pos = intrinsics.string_index_of(trimmed[i...@len(trimmed)], sep)

    if next_pos >= 0
      pos = i + next_pos
      i = pos + 1
    else
      i = @len(trimmed)
    end
  end

  # No separator found - the whole path is the basename
  if pos < 0
    return trimmed
  end

  # Everything after the last separator
  trimmed[pos + 1...@len(trimmed)]
end

# Get the extension of a path.
#
# Examples:
#   var ext = path.extension("file.tea")  # => "tea"
#   var ext = path.extension("file.tar.gz")  # => "gz"
#   var ext = path.extension(".env")  # => ""
#   var ext = path.extension("file")  # => ""
#
# Pure Tea implementation - returns everything after the last dot in the basename.
# Hidden files (starting with .) have no extension.
pub def extension(file_path: String) -> String
  var base = basename(file_path)

  if @len(base) == 0
    return ""
  end

  # Hidden files starting with . have no extension
  if base[0] == "."
    return ""
  end

  var last_dot = intrinsics.string_index_of(base, ".")
  var pos = last_dot
  var i = last_dot + 1

  # Find the last occurrence of dot
  while i < @len(base)
    var next_pos = intrinsics.string_index_of(base[i...@len(base)], ".")

    if next_pos >= 0
      pos = i + next_pos
      i = pos + 1
    else
      i = @len(base)
    end
  end

  # No dot found
  if pos < 0
    return ""
  end

  # Return everything after the last dot
  base[pos + 1...@len(base)]
end

# Normalize a path (remove . and .. components).
#
# Examples:
#   var norm = path.normalize("./foo/../bar")  # => "bar"
#   var norm = path.normalize("/usr/./local/../bin")  # => "/usr/bin"
#   var norm = path.normalize("a/b/c/../../d")  # => "a/d"
#
# Pure Tea implementation - splits path, processes . and .., then rejoins.
pub def normalize(file_path: String) -> String
  if @len(file_path) == 0
    return "."
  end

  var sep = intrinsics.path_separator()
  # Check if path is absolute by looking at first character
  var is_abs = @len(file_path) > 0 && file_path[0] == sep
  var parts = components(file_path)
  var stack = []
  var i = 0

  while i < @len(parts)
    var part = parts[i]

    if part == ".."
      # Go up one directory if possible
      if @len(stack) > 0
        var last = stack[@len(stack) - 1]
        # Don't pop if the last element is also ..
        if last != ".."
          stack = stack[0..@len(stack) - 1]
        else
          stack = stack +[".."]
        end
      else

        # No parent to go up to
        if ! is_abs
          stack = stack +[".."]
        end
      end
    else

      if part != "."
        stack = stack +[part]
      end
    end

    i = i + 1
  end

  # Build result
  var result = join(stack)

  if is_abs
    result = sep + result
  end

  if @len(result) == 0
    return "."
  end

  result
end

# Convert a path to absolute form.
#
# Examples:
#   var abs = path.absolute("file.txt")  # => "/current/dir/file.txt"
# Note: Two-argument form path.absolute(path, base) is not supported in Tea wrapper.
# Use path_absolute directly from intrinsics if needed.
pub def absolute(file_path: String) -> String
  intrinsics.path_absolute(file_path)
end

# Get the relative path from one path to another.
#
# Examples:
#   var rel = path.relative("/usr/local", "/usr/local/bin")  # => "bin"
pub def relative(from: String, to: String) -> String
  intrinsics.path_relative(from, to)
end

# Get the system path separator ("/" or "\").
#
# Examples:
#   var sep = path.separator()  # => "/" on Unix
pub def separator() -> String
  intrinsics.path_separator()
end

