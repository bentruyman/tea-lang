# Error Handling

Tea provides a robust error handling system with typed errors, explicit error declarations, and pattern matching for handling different error cases.

## Defining Error Types

Use the `error` keyword to define custom error types with variants.

<CodeCard>
{`error TeamError {
  NotFound(name: String)
  InvalidScore(score: Int)
}

error FileError {
  NotFound(path: String)
  PermissionDenied(path: String, user: String)
  IOError(message: String)
}`}
</CodeCard>

## Throwing Errors

Functions that can fail must declare their error types in their signature using `!`. Use `throw` to raise an error.

<Card className="p-6 bg-card border-border mb-4">

### Function Signatures

```tea
# Declare that this function can throw TeamError.NotFound
def find_team(name: String) -> Team ! TeamError.NotFound
  var idx = 0
  while idx < @len(teams)
    var candidate = teams[idx]
    if candidate.name == name
      return candidate
    end
    idx = idx + 1
  end

  # Throw the error when team isn't found
  throw TeamError.NotFound(name)
end
```

</Card>

<Card className="p-6 bg-card border-border">

### Multiple Error Types

```tea
# A function can throw multiple error types
def process_file(path: String) -> String ! FileError.NotFound, FileError.IOError
  if !file_exists(path)
    throw FileError.NotFound(path)
  end

  var content = read_file(path)
  if content == ""
    throw FileError.IOError("File is empty")
  end

  content
end
```

</Card>

## Catching Errors

Use `catch` to handle errors with pattern matching.

<Card className="p-6 bg-card border-border mb-4">

### Basic Catch

```tea
def announce_favorite(name: String) -> String
  var team = find_team(name) catch err
    case is TeamError.NotFound
      return `Sorry, ${err.name} is not on the schedule`
    case _
      return "Unexpected error occurred"
  end

  `Fan favorite: ${team.name}!`
end
```

</Card>

<Card className="p-6 bg-card border-border">

### Multiple Cases

```tea
def load_config(path: String) -> String
  var content = read_config(path) catch err
    case is FileError.NotFound
      return `Config not found: ${err.path}`
    case is FileError.PermissionDenied
      return `Access denied to ${err.path}`
    case is FileError.IOError
      return `Read error: ${err.message}`
    case _
      return "Unknown error"
  end

  content
end
```

</Card>

## Accessing Error Data

When catching an error, access its fields through the captured variable.

<CodeCard>
{`error ValidationError {
  InvalidEmail(email: String, reason: String)
  InvalidAge(age: Int, min: Int, max: Int)
}

def validate_user(email: String, age: Int) -> Bool ! ValidationError
  if !contains(email, "@")
    throw ValidationError.InvalidEmail(email, "missing @")
  end

  if age < 18 || age > 120
    throw ValidationError.InvalidAge(age, 18, 120)
  end

  true
end

def try_validate(email: String, age: Int) -> String
  var valid = validate_user(email, age) catch err
    case is ValidationError.InvalidEmail
      return \`Bad email "\${err.email}": \${err.reason}\`
    case is ValidationError.InvalidAge
      return \`Age \${err.age} must be between \${err.min}-\${err.max}\`
    case _
      return "Validation failed"
  end

  "User is valid"
end`}
</CodeCard>

## Panic

For unrecoverable errors, use `@panic` to immediately halt execution.

<Card className="p-6 bg-card border-border">

<AlertCard variant="warning">
  Panic should only be used for programming errors or impossible states, not for expected failures.
</AlertCard>

```tea
def divide(a: Int, b: Int) -> Int
  if b == 0
    @panic("division by zero")
  end
  a / b
end

# Using panic for assertions
use assert = "std.assert"

def test_add() -> Void
  assert.eq(1 + 1, 2)  # Panics if not equal
  assert.ok(true)      # Panics if false
end
```

</Card>

## Complete Example

<CodeCard>
{`struct Team {
  name: String
  wins: Int
  losses: Int
}

error TeamError {
  NotFound(name: String)
}

const format_team = |team: Team| => \`\${team.name}: \${team.wins} wins / \${team.losses} losses\`

const teams = [
  Team(name: "Ada", wins: 7, losses: 3),
  Team(name: "Grace", wins: 9, losses: 1),
  Team(name: "Linus", wins: 5, losses: 5)
]

def find_team(name: String) -> Team ! TeamError.NotFound
  var idx = 0
  while idx < @len(teams)
    var candidate = teams[idx]
    if candidate.name == name
      return candidate
    end
    idx = idx + 1
  end
  throw TeamError.NotFound(name)
end

## Announce the favorite team
def announce_favorite(name: String) -> String
  var team = find_team(name) catch err
    case is TeamError.NotFound
      return \`Sorry, \${err.name} is not on the schedule\`
    case _
      return "Unexpected lookup issue"
  end

  \`Fan favorite: \${format_team(team)}\`
end

@println(announce_favorite("Grace"))    # Found!
@println(announce_favorite("Unknown"))  # Not found`}
</CodeCard>

## Next Steps

<NextLink href="/docs/pattern-matching" title="Pattern Matching" description="Learn more about case expressions" />
<NextLink href="/docs/modules" title="Modules & Imports" description="Organize code and share error types" />
