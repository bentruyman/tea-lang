# Memory Management

Tea handles memory management automatically, letting you focus on writing code without worrying about allocations and deallocations.

## Automatic Memory Management

Tea automatically manages memory for all values. You don't need to manually allocate or free memory—the runtime handles it for you.

<CodeCard>
{`# Memory is automatically allocated
var users = [
  User(name: "Alice", age: 30),
  User(name: "Bob", age: 25)
]

# Memory is automatically freed when no longer needed
def process_data() -> String
  var temp = "temporary string"
  # temp is automatically cleaned up when function returns
  return "result"
end`}
</CodeCard>

## Value Semantics

Tea uses value semantics for most types. When you assign a value to a new variable or pass it to a function, a copy is made.

<Card className="p-6 bg-card border-border mb-4">

### Copying Values

```tea
struct Point {
  x: Int
  y: Int
}

var p1 = Point(x: 10, y: 20)
var p2 = p1  # p2 is a copy of p1

# Modifying p1 doesn't affect p2
# (assuming we could modify structs)
```

</Card>

<Card className="p-6 bg-card border-border">

### Benefits of Value Semantics

- **Predictable behavior** - No unexpected mutations through shared references
- **Thread safety** - Copies don't share state
- **Easier reasoning** - Function arguments can't be modified by the function

</Card>

## Stack and Heap Allocation

Tea's compiler automatically determines the most efficient allocation strategy.

<Card className="p-6 bg-card border-border">
  <div className="space-y-4">
    <div>
      <h3 className="font-semibold text-accent mb-2">Stack Allocation</h3>
      <p className="text-sm text-muted-foreground">
        Small, fixed-size values (integers, booleans, small structs) are typically allocated
        on the stack for fast access and automatic cleanup.
      </p>
    </div>
    <div>
      <h3 className="font-semibold text-accent mb-2">Heap Allocation</h3>
      <p className="text-sm text-muted-foreground">
        Dynamic-size values (strings, lists, larger structs) are allocated on the heap.
        The runtime manages their lifecycle.
      </p>
    </div>
  </div>

```tea
# Stack allocated (typically)
var count = 42
var flag = true

# Heap allocated (typically)
var name = "Hello, World!"
var numbers = [1, 2, 3, 4, 5]
```

</Card>

## String Handling

Tea strings are UTF-8 encoded and immutable. String operations create new strings rather than modifying existing ones.

<CodeCard>
{`var greeting = "Hello"
var message = greeting + ", World!"
# greeting is unchanged, message is a new string

# String interpolation creates new strings
var name = "Tea"
var welcome = \`Welcome to \${name}!\`
# A new string is allocated for welcome`}
</CodeCard>

## Collection Memory

Lists and dictionaries grow dynamically as needed. The runtime handles resizing.

<CodeCard>
{`# Lists grow as needed
var items = [1, 2, 3]
# Memory is managed automatically as the list grows

# Nested collections
var matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]
# Each inner list is separately managed`}
</CodeCard>

## LLVM Optimizations

Tea compiles to native code via LLVM, which applies various memory optimizations.

<Card className="p-6 bg-card border-border">
  <ul className="space-y-3 text-sm">
    <li className="flex items-start gap-3">
      <span className="text-accent">•</span>
      <span className="text-muted-foreground">
        <strong className="text-foreground">Escape analysis</strong> - Values that don't escape can stay on the stack
      </span>
    </li>
    <li className="flex items-start gap-3">
      <span className="text-accent">•</span>
      <span className="text-muted-foreground">
        <strong className="text-foreground">Copy elision</strong> - Unnecessary copies are eliminated
      </span>
    </li>
    <li className="flex items-start gap-3">
      <span className="text-accent">•</span>
      <span className="text-muted-foreground">
        <strong className="text-foreground">Inlining</strong> - Small functions are inlined to reduce overhead
      </span>
    </li>
    <li className="flex items-start gap-3">
      <span className="text-accent">•</span>
      <span className="text-muted-foreground">
        <strong className="text-foreground">Dead code elimination</strong> - Unused allocations are removed
      </span>
    </li>
  </ul>
</Card>

## Best Practices

<Card className="p-6 bg-card border-border">
  <ul className="space-y-3 text-sm">
    <li className="flex items-start gap-3">
      <span className="text-accent">1.</span>
      <span className="text-muted-foreground">
        <strong className="text-foreground">Prefer const</strong> - Immutable values are easier to optimize
      </span>
    </li>
    <li className="flex items-start gap-3">
      <span className="text-accent">2.</span>
      <span className="text-muted-foreground">
        <strong className="text-foreground">Avoid excessive string concatenation</strong> - Build strings efficiently with interpolation
      </span>
    </li>
    <li className="flex items-start gap-3">
      <span className="text-accent">3.</span>
      <span className="text-muted-foreground">
        <strong className="text-foreground">Keep scopes small</strong> - Variables are cleaned up when they go out of scope
      </span>
    </li>
    <li className="flex items-start gap-3">
      <span className="text-accent">4.</span>
      <span className="text-muted-foreground">
        <strong className="text-foreground">Use native compilation for performance</strong> - `tea build` produces optimized binaries
      </span>
    </li>
  </ul>
</Card>

## Next Steps

<NextLink href="/docs/metaprogramming" title="Metaprogramming" description="Compile-time code generation" />
<NextLink href="/docs/concurrency" title="Concurrency" description="Memory safety in concurrent code" />
